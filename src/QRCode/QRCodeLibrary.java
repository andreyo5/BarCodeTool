package QRCode;

import java.util.Arrays;

public class QRCodeLibrary {
    public String[] symbols;
    public int[] maxInfoAmount_M;
    public int[] blocksInfoAmount_M;
    public int[] bytesOfCorrection_M;
    private int[][] generatingPolynomials_M;
    public int[] GaloisField;
    public int[] inverseGaloisField;
    public int[][] locationsOfAligmentPatterns;
    public String[][] versionpattern;
    public String[][] mask_M;
    //-----patterns-----
    public String[][] search_pattern;
    public String[][] aligment_pattern;
    
    public int version=0;

    public QRCodeLibrary(){
        symbols = new String[]{"0","1","2","3","4","5","6","7","8","9",
        "A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z"," ",
        "$","%","*","+","-",".","/",":"};

        maxInfoAmount_M = new int[]{0,
            128,224,352,512,688,864,992,1232,1456,1728, // индекс == версия кодировки
            2032,2320,2672,2920,3320,3624,4056,4504,5016,5352,
            5712,6256,6880,7312,8000,8496,9024,9544,10136,10984,
            1164012328,13048,13800,14496,15312,15936,16816,17728,18672
        };

        blocksInfoAmount_M = new int[]{0,   // индекс == количество блоков
            1,1,1,2,2,4,4,4,5,5,            // таблица блоков байтов
            5,8,9,9,10,10,11,13,14,16,
            17,17,18,20,21,23,25,26,28,29,
            31,33,35,37,38,40,43,45,47,49
        };
        bytesOfCorrection_M = new int[]{0, //индекс соответствует версии
            10,16,26,18,24,16,18,22,22,26,  // таблица байтов корекции
            30,22,22,24,24,28,28,26,26,26,
            26,28,28,28,28,28,28,28,28,28,
            28,28,28,28,28,28,28,28,28,28
        };
        generatingPolynomials_M = new int[][]{ // первое значение каждой строки - коректирующий бит, последующие - части многочлена
            {7,87,229,146,149,238,102,21},
            {10,251,67,46,61,118,70,64,94,32,45},
            {13,74,152,176,100,86,100,106,104,130,218,206,140,78},
            {15,8,183,61,91,202,37,51,58,58,237,140,124,5,99,105},
            {16,120,104,107,109,102,161,76,3,91,191,147,169,182,194,225,120},
            {17,43,139,206,78,43,239,123,206,214,147,24,99,150,39,243,163,136},
            {18,215,234,158,94,184,97,118,170,79,187,152,148,252,179,5,98,96,153},
            {20,17,60,79,50,61,163,26,187,202,180,221,225,83,239,156,164,212,212,188,190},
            {22,210,171,247,242,93,230,14,109,221,53,200,74,8,172,98,80,219,134,160,105,165,231},
            {24,229,121,135,48,211,117,251,126,159,180,169,152,192,226,228,218,111,0,117,232,87,96,227,21},
            {26,173,125,158,2,103,182,118,17,145,201,111,28,165,53,161,21,245,142,13,102,48,227,153,145,218,70},
            {28,168,223,200,104,224,234,108,180,110,190,195,147,205,27,232,201,21,43,245,87,42,195,212,119,242,37,9,123},
            {30,41,173,145,152,216,31,179,182,50,48,110,86,239,96,222,125,42,173,226,193,224,130,156,37,251,216,238,40,192,180},
        };

        GaloisField = new int[]{
            1,2,4,8,16,32,64,128,29,58,116,232,205,135,19,38,
            76,152,45,90,180,117,234,201,143,3,6,12,24,48,96,192,
            157,39,78,156,37,74,148,53,106,212,181,119,238,193,159,35,
            70,140,5,10,20,40,80,160,93,186,105,210,185,111,222,161,
            95,190,97,194,153,47,94,188,101,202,137,15,30,60,120,240,
            253,231,211,187,107,214,177,127,254,225,223,163,91,182,113,226,
            217,175,67,134,17,34,68,136,13,26,52,104,208,189,103,206,
            129,31,62,124,248,237,199,147,59,118,236,197,151,51,102,204,
            133,23,46,92,184,109,218,169,79,158,33,66,132,21,42,84,
            168,77,154,41,82,164,85,170,73,146,57,114,228,213,183,115,
            230,209,191,99,198,145,63,126,252,229,215,179,123,246,241,255,
            227,219,171,75,150,49,98,196,149,55,110,220,165,87,174,65,
            130,25,50,100,200,141,7,14,28,56,112,224,221,167,83,166,
            81,162,89,178,121,242,249,239,195,155,43,86,172,69,138,9,
            18,36,72,144,61,122,244,245,247,243,251,235,203,139,11,22,
            44,88,176,125,250,233,207,131,27,54,108,216,173,71,142,1
        };

        inverseGaloisField = new int[]{0,
            0,1,25,2,50,26,198,3,223,51,238,27,104,199,75,
            4,100,224,14,52,141,239,129,28,193,105,248,200,8,76,113,
            5,138,101,47,225,36,15,33,53,147,142,218,240,18,130,69,
            29,181,194,125,106,39,249,185,201,154,9,120,77,228,114,166,
            6,191,139,98,102,221,48,253,226,152,37,179,16,145,34,136,
            54,208,148,206,143,150,219,189,241,210,19,92,131,56,70,64,
            30,66,182,163,195,72,126,110,107,58,40,84,250,133,186,61,
            202,94,155,159,10,21,121,43,78,212,229,172,115,243,167,87,
            7,112,192,247,140,128,99,13,103,74,222,237,49,197,254,24,
            227,165,153,119,38,184,180,124,17,68,146,217,35,32,137,46,
            55,63,209,91,149,188,207,205,144,135,151,178,220,252,190,97,
            242,86,211,171,20,42,93,158,132,60,57,83,71,109,65,162,
            31,45,67,216,183,123,164,118,196,23,73,236,127,12,111,246,
            108,161,59,82,41,157,85,170,251,96,134,177,187,204,62,90,
            203,89,95,176,156,169,160,81,11,245,22,235,122,117,44,215,
            79,174,213,233,230,231,173,232,116,214,244,234,168,80,88,175
        };
        locationsOfAligmentPatterns = new int[][]{
            {1,21},
            {2,18},
            {3,22},
            {4,26},
            {5,30},
            {6,34},
            {7,6, 22, 38},          //
            {8,6, 24, 42},          //
            {9,6, 26, 46},          // первый элемент строки означает версию - последующие узоры
            {10,6, 28, 50},         //
            {11,6, 30, 54},         //
            {12,6, 32, 58},
            {13,6, 34, 62},
            {14,6, 26, 46, 66},
            {15,6, 26, 48, 70},
            {16,6, 26, 50, 74},
            {17,6, 30, 54, 78},
            {18,6, 30, 56, 82},				
            {19,6, 30, 58, 86},
            {20,6, 34, 62, 90},
            {21,6, 28, 50, 72, 94},
            {22,6, 26, 50, 74, 98},
            {23,6, 30, 54, 78, 102},				
            {24,6, 28, 54, 80, 106},
            {25,6, 32, 58, 84, 110},
            {26,6, 30, 58, 86, 114},
            {27,6, 34, 62, 90, 118},
            {28,6, 26, 50, 74, 98, 122},			
            {29,6, 30, 54, 78, 102, 126},
            {30,6, 26, 52, 78, 104, 130},
            {31,6, 30, 56, 82, 108, 134},			
            {32,6, 34, 60, 86, 112, 138},
            {33,6, 30, 58, 86, 114, 142},
            {34,6, 34, 62, 90, 118, 146},
            {35,6, 30, 54, 78, 102, 126, 150},			
            {36,6, 24, 50, 76, 102, 128, 154},
            {37,6, 28, 54, 80, 106, 132, 158},
            {38,6, 32, 58, 84, 110, 136, 162},
            {39,6, 26, 54, 82, 110, 138, 166},
            {40,6, 30, 58, 86, 114, 142, 170}
        };

        versionpattern = new String[][]{
            {"7","000010 011110 100110"}, // первое число версия - второе паттерн
            {"8","010001 011100 111000"},
            {"9","110111 011000 000100"},
            {"10","101001 111110 000000"},
            {"11","001111 111010 111100"},
            {"12","001101 100100 011010"},
            {"13","101011 100000 100110"},
            {"14","110101 000110 100010"},
            {"15","010011 000010 011110"},
            {"16","011100 010001 011100"},
            {"17","111010 010101 100000"},
            {"18","100100 110011 100100"},
            {"19","000010 110111 011000"},
            {"20","000000 101001 111110"},
            {"21","100110 101101 000010"},
            {"22","111000 001011 000110"},
            {"23","011110 001111 111010"},
            {"24","001101 001101 100100"},
            {"25","101011 001001 011000"},
            {"26","110101 101111 011100"},
            {"27","010011 101011 100000"},
            {"28","010001 110101 000110"},
            {"29","110111 110001 111010"},
            {"30","101001 010111 111110"},
            {"31","001111 010011 000010"},
            {"32","101000 011000 101101"},
            {"33","001110 011100 010001"},
            {"34","010000 111010 010101"},
            {"35","110110 111110 101001"},
            {"36","110100 100000 001111"},
            {"37","010010 100100 110011"},
            {"38","001100 000010 110111"},
            {"39","101010 000110 001011"},
            {"40","111001 000100 010101"}
        };
        mask_M = new String[][]{
            {"0","101010000010010"},
            {"1","101000100100101"},  // первое число код макси второе код
            {"2","101111001111100"},
            {"3","101101101001011"},
            {"4","100010111111001"},
            {"5","100000011001110"},
            {"6","100111110010111"},
            {"7","100101010100000"}
        };
        search_pattern = new String[][]{
            {"1","1","1","1","1","1","1"},
            {"1","0","0","0","0","0","1"},
            {"1","0","1","1","1","0","1"},
            {"1","0","1","1","1","0","1"},
            {"1","0","1","1","1","0","1"},
            {"1","0","0","0","0","0","1"},
            {"1","1","1","1","1","1","1"}
        };
        aligment_pattern = new String[][]{
            {"1","1","1","1","1"},
            {"1","0","0","0","1"},
            {"1","0","1","0","1"},
            {"1","0","0","0","1"},
            {"1","1","1","1","1"}
        };

    }

    public int[] getPolynomials_M(int byte_of_correction){
        // [line][col]
        int[] a=new int[1];// временный массив для получения многочлена
        for (int i = 0; i < 13; i++) {
            if(byte_of_correction==generatingPolynomials_M[i][0]){
                int length = generatingPolynomials_M[i].length;
                a = new int[length-1];// временный массив для получения многочлена
                for (int j = 1; j < length; j++) {
                    a[j-1]=generatingPolynomials_M[i][j];
                }
                break;
            }
        }
        return a;
    }
    public int getIndex(String symbol){
        int index =0;
        for(int i = 0;i<symbols.length;i++){
            if(symbol.equals(symbols[i])){
                index=i;
                break;
            }
        }
        return index;
    }

    public int getVersion(int length){
        int index =0;
        length*=8;
        for(int i = 0;i<maxInfoAmount_M.length;i++){
            if(length<=maxInfoAmount_M[i]){
                index=i;
                break;
            }
        }
        version=index;
        return index;
    }

    public int getSize(int version){
        int index =0;
        for(int i = 0;i<locationsOfAligmentPatterns.length;i++){
            if(locationsOfAligmentPatterns[i][0]==version){
                index = locationsOfAligmentPatterns[i][locationsOfAligmentPatterns[i].length-1]+7;
                break;
            }
        }
        return index;
    }
    public int[] getLocationsOfAligmentPatterns(int version){
        int[] a=new int[0];
        for(int i = 0;i<locationsOfAligmentPatterns.length;i++){
            if(locationsOfAligmentPatterns[i][0]==version){
                a = new int[locationsOfAligmentPatterns[i].length-1];
                for (int j = 0; j < locationsOfAligmentPatterns[i].length; j++) {
                    try {
                        a[j]=locationsOfAligmentPatterns[i][j+1];
                    } catch (Exception e) {
                    }
                }
            }
        }
        return a;
    }
    public String[] getVersionPattern(int version){
        String[] patterns = new String[3];
        String _version = Integer.toString(version);
        for(int i = 0;i<versionpattern.length;i++){
            if(versionpattern[i][0].equals(_version)){
                String a = versionpattern[i][1];
                patterns = a.split(" ");
                break;
            }
        }
        return patterns;
    }
    public String getMask(int version){
        String a="";
        for(int i = 0;i<mask_M.length;i++){
            if(mask_M[i][0].equals(String.valueOf(version))){
                a = mask_M[i][1];
                break;
            }
        }
        return a;
    }

    public int[] generateCorrectionBytes(int[] currentBlock, int correctionBytesCount) {
        int maxLength = Math.max(currentBlock.length, correctionBytesCount);
        int[] preparedArray = new int[maxLength];
        System.arraycopy(currentBlock, 0, preparedArray, 0, currentBlock.length);
        
        for (int i = 0; i < currentBlock.length; i++) {
            int A = preparedArray[0];
            System.arraycopy(preparedArray, 1, preparedArray, 0, preparedArray.length - 1);
            preparedArray[preparedArray.length - 1] = 0;
            if (A == 0) {
                continue;
            }
            int B = inverseGaloisField[A];

            for (int j = 0; j < correctionBytesCount; j++) {
                int V = GaloisField[j];
                V += B;

                if (V > 254) {
                    V %= 255;
                }
                preparedArray[j] ^= V;
            }
        }
        return Arrays.copyOf(preparedArray, correctionBytesCount);
    }
}
